<!DOCTYPE html>
<html>
<head>
    <title>Viewer</title>
</head>
<body>
    <canvas id="viewport"></canvas>
<style>
:root {
  --border: #ccc;
  --panel-background: white;
  --primary: #101010;
  --secondary: #6c757d;
}
body {
  font-family: 'Roboto', sans-serif;
}
.controls {
  display: flex;
  justify-content: center;
  width: 38ch;
  background: var(--panel-background);
  color: var(--primary);
  max-width: 100%;
  overflow-y: scroll;
}

.dropdown > label, .slider > label {
  display: block;
}

.dropdown > select, .slider > input {
  width: 100%;
}

.dropdown select {
  height: 2rem;
  color: var(--primary);
  border: 1px solid var(--border);
  border-radius: 0px;
}

.row {
  margin: 0.6rem 0 1.2rem 0;
}
.row:last-child {
  margin-bottom: 0;
}

.controls fieldset {
    border: 1px solid var(--border);
    border-radius: 0.4rem;
    margin: 0.3rem 0 0.6rem 0;
    padding: 0.5rem;
}
.controls legend {
  color: var(--secondary);
  cursor: default;
}
/*hint is secondary color*/
.input-hint {
  color: var(--secondary);
  font-size: 0.8rem;
}

.panel {
  display: flex;
  flex-direction: column;
  margin: 0 1ch;
}
.tabs {
  width: 100%;
}
.tabs [type="radio"] {
	display: none;
}

.row-group {
  display: flex;
  flex-direction: row;
  gap: 0.4em;
}

.tabs .tabs-header {
  display: flex;
  align-items: stretch;
  list-style: none;
  padding: 0;
  margin: 0 0 0.6rem 0;
}
.tabs .tabs-header > label {
  padding: 1rem;
}
.tabs [type="radio"]:nth-of-type(1):checked ~ .tabs-header label:nth-of-type(1),
.tabs [type="radio"]:nth-of-type(2):checked ~ .tabs-header label:nth-of-type(2),
.tabs [type="radio"]:nth-of-type(3):checked ~ .tabs-header label:nth-of-type(3),
.tabs [type="radio"]:nth-of-type(4):checked ~ .tabs-header label:nth-of-type(4),
.tabs [type="radio"]:nth-of-type(5):checked ~ .tabs-header label:nth-of-type(5) {
  background: var(--primary);
  color: white;
}

.tabs .tab {
  display: none;
}
.tabs [type="radio"]:nth-of-type(1):checked ~ .tab:nth-of-type(1),
.tabs [type="radio"]:nth-of-type(2):checked ~ .tab:nth-of-type(2),
.tabs [type="radio"]:nth-of-type(3):checked ~ .tab:nth-of-type(3),
.tabs [type="radio"]:nth-of-type(4):checked ~ .tab:nth-of-type(4) {
	display: block;
}

.controls button {
  height: 2rem;
  width: 100%;
  border: none;
}


html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
  position: relative;
}
#viewport {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: -999;
}

</style>

    <div class="controls">
      <div class="tabs">
        <input type="radio" id="tab-1" name="accordion-1" checked>
        <input type="radio" id="tab-2" name="accordion-1">

        <span class="tabs-header">
          <label for="tab-1">Control</label>
          <label for="tab-2">Trajectory</label>
        </span>
        <div class="tab panel">
          <fieldset>
            <legend>Render options</legend>
            <div class="row slider">
              <label for="max-res">Max res</label>
              <input type="range" id="max-res" min="64" max="2048" value="100">
            </div>

            <div class="row dropdown">
              <label for="output-type">Output type</label>
              <select id="output-type">
                <option value="not set">not set</option>
              </select>
            </div>
          </fieldset>
          <fieldset id="folder-split-screen">
            <legend>Split screen</legend>
            <div class="row checkbox">
              <label for="output_split">Enable split screen</label>
              <input type="checkbox" id="output_split" name="output_split">
            </div>

            <div class="row slider">
              <label for="split_percentage">Split percentage</label>
              <input type="range" id="split_percentage" min="0" max="1" step="0.01" value="0.5">
              <div class="input-hint">Where to split</div>
            </div>

            <div class="row dropdown">
              <label for="output-render-split">Output render split</label>
              <select id="output-render-split">
                <option value="not set">not set</option>
              </select>
              <div class="input-hint">The second output</div>
            </div>
          </fieldset>
          <div class="row checkbox">
            <label for="show_train_cameras">Show train cams</label>
            <input type="checkbox" id="show_train_cameras" name="show_train_cameras" disabled>
          </div>
          <div class="row checkbox">
            <label for="show_test_cameras">Show test cams</label>
            <input type="checkbox" id="show_test_cameras" name="show_test_cameras" disabled>
          </div>
          <div class="row checkbox">
            <label for="show_input_points">Show input PC</label>
            <input type="checkbox" id="show_input_points" name="show_input_points" disabled>
          </div>
          <button id="reset-camera">Reset up direction</button>
        </div>
        <div class="tab panel">
          <!-- Render -->
          <div class="row">
            <label for="render_fov">Default FOV</label>
            <input type="range" id="render_fov" name="render_fov" min="0.1" max="175" step="0.01" value="60">
          </div>

          <div class="row">
            <label for="render_resolution">Resolution</label>
            <input type="range" id="render_resolution" name="render_resolution" min="50" max="10000" step="1" value="100">
          </div>

          <div class="row dropdown">
            <label for="render_appearance_train_index">Appearance train index</label>
            <select id="render_appearance_train_index" name="render_appearance_train_index">
              <option value="not set">not set</option>
            </select>
          </div>

          <div class="row row-group">
            <button id="button_add_keyframe" title="Add a new keyframe at the current pose.">Add keyframe</button>
            <button id="button_clear_keyframes" title="Remove all keyframes from the render path.">Clear keyframes</button>
          </div>


          <fieldset>
            <legend>Playback</legend>
              <div class="row row-group">
                <button id="button_play">Play</button>
                <button id="button_pause">Pause</button>
                <button id="button_preview_render">Preview render</button>
                <button id="button_preview_render_stop">Exit render preview</button>
              </div>

              <div class="row number">
                <label for="camera_path_default_transition_duration">Transition (sec)</label>
                <input type="number" id="camera_path_default_transition_duration" name="camera_path_default_transition_duration" min="0.001" max="30" step="0.001" value="1">
                <div class="input-hint">Time in seconds between each keyframe, which can also be overridden on a per-transition basis.</div>
              </div>

              <div class="row number">
                <label for="camera_path_framerate">FPS</label>
                <input type="number" id="camera_path_framerate" name="camera_path_framerate" min="0.1" max="240" step="0.01" value="30">
              </div>

              <div class="row row-group">
                <button onclick="document.getElementById('camera_path_framerate').value = 24">24</button>
                <button onclick="document.getElementById('camera_path_framerate').value = 30">30</button>
                <button onclick="document.getElementById('camera_path_framerate').value = 60">60</button>
              </div>

              <div class="row number">
                <label for="camera_path_duration">Duration (sec)</label>
                <input type="number" id="camera_path_duration" name="camera_path_duration" min="0.001" max="1e8" step="0.001" value="1">
                <div class="input-hint">Total duration of the camera path in seconds.</div>
              </div>

              <div class="row slider">
                <label for="preview_frame">Preview frame</label>
                <input type="range" id="preview_frame" name="preview_frame" min="0" step="1" value="0">
              </div>
          </fieldset>

          <div class="row dropdown">
            <label for="camera_path_interpolation">Interpolation</label>
            <select id="camera_path_interpolation" name="camera_path_interpolation">
              <option value="kochanek-bartels">kochanek-bartels</option>
              <option value="none">none</option>
              <option value="ellipse">ellipse</option>
            </select>
            <div class="input-hint">Camera path interpolation.</div>
          </div>

          <div class="row checkbox">
            <label for="camera_path_loop">Loop</label>
            <input type="checkbox" id="camera_path_loop" name="camera_path_loop">
            <div class="input-hint">Add a segment between the first and last keyframes.</div>
          </div>

          <div class="row slider">
            <label for="camera_path_tension">Spline tension</label>
            <input type="range" id="camera_path_tension" name="camera_path_tension" min="0" max="1" step="0.01" value="0.5">
            <div class="input-hint">Tension parameter for adjusting smoothness of spline interpolation.</div>
          </div>

          <div class="row checkbox">
            <label for="camera_path_move_keyframes">Move keyframes</label>
            <input type="checkbox" id="camera_path_move_keyframes" name="camera_path_move_keyframes">
            <div class="input-hint">Toggle move handles for keyframes in the scene.</div>
          </div>

          <div class="row checkbox">
            <label for="camera_path_show_keyframes">Show keyframes</label>
            <input type="checkbox" id="camera_path_show_keyframes" name="camera_path_show_keyframes">
            <div class="input-hint">Show keyframes in the scene.</div>
          </div>

          <div class="row checkbox">
            <label for="camera_path_show_spline">Show spline</label>
            <input type="checkbox" id="camera_path_show_spline" name="camera_path_show_spline">
            <div class="input-hint">Show camera path spline in the scene.</div>
          </div>

          <div class="row row-group">
            <button id="button_load_camera_path">Load trajectory</button>
            <button id="button_export_camera_path">Export trajectory</button>
          </div>
          <button id="button_render_video">Render video</button>
        </div>
      </div>
    </div>

    <script>

    </script>


    <script>
      const canvas = document.getElementById("viewport");
      const ctx = canvas.getContext("2d");

      const renderers = [];
      const state = {
        renderers: {},
      };

      class HTTPRenderer {
        constructor(baseUrl) {
          this._baseUrl = baseUrl;
          // Generate uuid
          this.state = null;
          this.onUpdateFrame = null;
          this.onUpdateState = null;

        }

        async updateRenderParams(renderParams) {
          await fetch(`${this._baseUrl}/set-feed-params?feedid=${this.state.feedid}`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify(renderParams),
          });
        }

        async _run(reader) {
          const boundary = "frame"; // Boundary from server response
          const boundaryBytes = new TextEncoder().encode(`--${boundary}`);
          const headerSeparator = new Uint8Array([13, 10, 13, 10]); // "\r\n\r\n"

          let buffer = new Uint8Array(0);

          while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            // Concatenate new data into buffer
            const tempBuffer = new Uint8Array(buffer.length + value.length);
            tempBuffer.set(buffer);
            tempBuffer.set(value, buffer.length);
            buffer = tempBuffer;

            // Process all frames in the current buffer
            while (true) {
              const boundaryIndex = this._findSequence(buffer, boundaryBytes);
              if (boundaryIndex === -1) break;

              const headerEndIndex = this._findSequence(buffer, headerSeparator, boundaryIndex + boundaryBytes.length);
              if (headerEndIndex === -1) break;

              const frameStart = headerEndIndex + headerSeparator.length;
              const nextBoundaryIndex = this._findSequence(buffer, boundaryBytes, frameStart);
              if (nextBoundaryIndex === -1) break;

              const frameData = buffer.slice(frameStart, nextBoundaryIndex);

              // Create a Blob and update the image element
              const blob = new Blob([frameData], { type: "image/jpeg" });
              const image = new Image();
              image.src = URL.createObjectURL(blob);
              image.onload = () => {
                if (this.onUpdateFrame) {
                  this.onUpdateFrame(image);
                }
              };

              // Remove processed data from the buffer
              buffer = buffer.slice(nextBoundaryIndex);
            }
          }
        }

        async _run_polling() {
          while (this._running) {
            try {
              const response = await fetch(`/get-state?poll=${this.state.version}&feedid=${this.state.feedid}`);
              if (!response.ok) {
                  throw new Error("Network response was not ok");
              }
              const data = await response.json();
              const oldVersion = this.state.version;
              if (data) {
                this.state = Object.assign(this.state, data);
              }
              if (this.state.version != oldVersion && this.onUpdateState) {
                this.onUpdateState(data);
              }
            } catch (error) {
              console.error("Error fetching updates:", error);

              // Retry after a delay in case of an error
              await new Promise((resolve) => setTimeout(resolve, 1000));
            }
          }
        }


        async start() {
          this.state = {};
          const setFeedResponse = await fetch(this._baseUrl + "/set-feed-params", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              width: canvas.clientWidth,
              height: canvas.clientHeight,
            }),
          }).then((response) => response.json());
          if (setFeedResponse.status !== "ok") throw exception("Failed to set feed params");
          this.state.feedid = setFeedResponse.feedid;
          this.state.version = 0;
          const response = await fetch(`${this._baseUrl}/video-feed?feedid=${this.state.feedid}`);
          if (!response.body) {
            throw new Error("ReadableStream not yet supported in this browser");
          }
          const reader = response.body.getReader();


          // NOTE: We start the async loop here
          this._running = true;
          this._run(reader).catch((err) => {
            console.error("Error:", err);
          });
          this._run_polling().catch((err) => {
            console.error("Error:", err);
          });
        }

        _findSequence(buffer, sequence, startIndex = 0) {
          for (let i = startIndex; i <= buffer.length - sequence.length; i++) {
            let found = true;
            for (let j = 0; j < sequence.length; j++) {
              if (buffer[i + j] !== sequence[j]) {
                found = false;
                break;
              }
            }
            if (found) return i;
          }
          return -1;
        }
      }

      const lastFrames = {};
      function draw() {
        if (lastFrames[0]) {
          ctx.drawImage(lastFrames[0], 0, 0);
        }
      }

      async function start() {
        const renderer = new HTTPRenderer("http://localhost:5001");
        await renderer.start();

        renderer.onUpdateFrame = (frame) => {
          lastFrames[0] = frame;
          draw();
        };
        // renderer.onUpdateState = (state) => {
        //   console.log("State:", renderer.state, state);
        // };
        renderers.push(renderer);
      }

      canvas.width = canvas.clientWidth;
      canvas.height = canvas.clientHeight;
      start();

      window.addEventListener("resize", async () => {
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
        draw();
        for (const renderer of renderers) {
          await renderer.updateRenderParams({
            width: canvas.clientWidth,
            height: canvas.clientHeight,
          }).catch((err) => {
            console.error("Error updating render params:", err);
          });
        }
      });
      
      // Implement WebRTC
    </script>
</body>
</html>
